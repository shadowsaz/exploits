if not getgenv()._355743517261299712 then
	local lib = setmetatable({},{
		__index = function(self,name)
			local success,service = pcall(game.GetService,game,name)
			if success then self[name] = service return service
			else error("Indexed non-existant service \"", name.."\"") return nil end
		end,
		Objects = {Signal = {Spawned = {}},Connection = {}}
	})
	warn("hi")
	local Signal = lib.Objects.Signal
	local Connection = lib.Objects.Connection
	function lib:GrabSignal(index) return Signal.Spawned[index] end
	function lib:SpawnSignal(index)
		if Signal.Spawned[index] then error("Signal with the same index already exists.") return end
		local self = {Active = true,Index = index,Connections = {},Threads = {}}
		if index then Signal.Spawned[index] = self end
		return setmetatable(self,Signal)
	end
	function Connection:Spawn(signal) return setmetatable({Signal = signal},Connection) end
	function Connection:Disconnect() self.Signal.Connections[self] = nil end
	function Signal:ActiveCheck()
		if not self.Active then 
			warn("Called signal is no longer active.") 
		end
		return self.Active
	end
	function Signal:Fire(...)
		if not self:ActiveCheck() then return end 
		for _,func in pairs(self.Connections) do task.spawn(func,...) end 
	end
	function Signal:Connect(func)
		if not self:ActiveCheck() then return nil end
		local con = Connection:Spawn(self)
		self.Connections[con] = func
		return con
	end
	function Signal:Invoke(...)
		if self:ActiveCheck() and self.OnInvoke then return self.OnInvoke(...) end
		return nil
	end
	function Signal:SetInvoke(func)
		if self:ActiveCheck() then self.OnInvoke = func end
	end
	function Signal:RemoveInvoke()
		if self:ActiveCheck() then self.OnInvoke = nil end
	end
	function Signal:Wait(timeout)
		if not self:ActiveCheck() then return "Cancel" end
		local con,thread;
		local called = false
		local function remove(state,...)
			if not called and self:ActiveCheck() then
				called = true
				con:Disconnect()
				self.Threads[thread] = nil
				task.spawn(thread,state,...)
			end
		end
		con = self:Connect(function(...) remove("Finish",...) end)
		if timeout then task.delay(timeout,remove,"Timeout") end
		thread = coroutine.running()
		self.Threads[thread] = true
		return coroutine.yield()
	end
	function Signal:Destroy()
		if not self:ActiveCheck() then return end
		self.Active = false
		if self.Index then Signal.Spawned[self.Index] = nil end
		for thread in pairs(self.Threads) do task.spawn(thread,"Cancel") end
	end
	function lib:SafeDestroy(object,waitTime)
		task.spawn(function()
			if waitTime then task.wait(waitTime) end
			if object then object:Destroy() end
			object = nil
		end)
	end
	function lib:WaitFor(parent,name,callback)
		local child = parent:FindFirstChild(name)
		if not child then
			local con;con = parent.ChildAdded:Connect(function(new)
				if new.Name == name then
					con:Disconnect()
					callback(new)
				end
			end)
			return con
		end
		return child
	end

	function lib:CreateBase(mode,child,root,offset)
		local part = root
		if mode then
			part = Instance.new("Part")
			part.Name = "EspBase"
			part.CanCollide = false
			part.Locked = true
			part.Transparency = 1
			part.Size = Vector3.new(.1,.1,.1)
			if root then
				part.CFrame = root.CFrame*(offset or CFrame.new(0,0,0))
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = part
				weld.Part1 = root
				weld.Parent = part
				part.Parent = root
			else part.Anchored = true end
		end
		return {
			Child = child,
			Root = part,
			Color = Color3.fromRGB(255,175,0),
			ColorChanged = lib:SpawnSignal(),
			ChangeColor = function(self,color)
				self.Color = color
				self.ColorChanged:Fire()
			end,
			Destroy = function(self)
				self.ColorChanged:Destroy()
				lib:SafeDestroy(self.Button)
				lib:SafeDestroy(self.Text)
				lib:SafeDestroy(self.Root)
			end
		}
	end
	function lib:CreateText(base,esp,data)
		local board = Instance.new("BillboardGui")
		board.Enabled = esp.Enabled
		base.Text = board
		board.ChildAdded:Connect(function(label) 
			if label:IsA("TextLabel") then label.TextColor3 = base.Color end 
		end)
		base.ColorChanged:Connect(function()
			for _,label in ipairs(board:GetChildren()) do
				if label:IsA("TextLabel") then label.TextColor3 = base.Color end
			end
		end)
		board.Name = "EspText"
		board.Active = true
		board.AlwaysOnTop = true
		board.ResetOnSpawn = false
		board.Size = UDim2.fromOffset(115,0)
		board.StudsOffset = Vector3.new(0,.5,0)
		for i,arg in ipairs(data) do
			local name,func = arg[1],arg[2]
			local label = Instance.new("TextLabel")
			label.Name = name
			label.Text = name
			label.AnchorPoint = Vector2.new(.5,0)
			label.BackgroundTransparency = 1
			label.TextStrokeTransparency = 0
			label.Font = Enum.Font.GothamBlack
			label.TextScaled = true
			label.Size = UDim2.new(1,0,0,10)
			label.Position = UDim2.new(.5,0,0,(10*i)-10)
			board.Size = UDim2.fromOffset(115,board.Size.Y.Offset+10)
			if func then func(label) end
			label.Parent = board
		end
		syn.protect_gui(board)
		board.Adornee = base.Root
		board.Parent = lib.CoreGui.CoreBase
		return board
	end
	function lib:CreateButton(data,esp,base)
		if not base.Text or base.Button then return end
		local board = base.Text
		local x,y = board.Size.X.Offset,board.Size.Y.Offset
		local button = Instance.new("TextButton")
		button.Name = "EspButton"
		button.AnchorPoint = Vector2.new(.5,.5)
		button.BackgroundTransparency = .65
		button.BorderSizePixel = 1
		button.BorderColor3 = Color3.fromRGB(0,0,0)
		button.TextTransparency = 1
		button.Size = UDim2.fromOffset(x-1,y-1)
		button.Position = UDim2.fromScale(.5,.5)
		button.ZIndex = 999999999
		button.MouseButton1Click:Connect(function() 
			data:OnClicked(esp,base) 
		end)
		syn.protect_gui(button)
		base.Button = button
		button.Parent = base.Text
		return button
	end
	function lib:CreateEsp(data)
		local esp = {
			Enabled = false,
			ToggleKey = data._ToggleKey,
			ButtonKey = data._ButtonKey,
			BaseQueue = {},
			_CoreCons = {},
			Toggle = function(self,destroy)
				self.Enabled = not self.Enabled
				if not destroy then data.Toggled:Fire(self.Enabled) end
				for _,base in ipairs(self.BaseQueue) do 
					if not self.Enabled and base.Button then base.Button:Destroy() end
					if base.Text then base.Text.Enabled = self.Enabled end
				end
			end,
			Destroy = function(self)
				for _,con in ipairs(self._CoreCons) do con:Disconnect() end
				if self.Enabled then self:Toggle(true) end
				for index,base in ipairs(self.BaseQueue) do 
					data:OnRemoved(self,base)
					base:Destroy()
					table.remove(self.BaseQueue,index)
				end
				data:OnDestroy(self)
			end
		}
		data:OnCreate(esp)
		for _,folder in ipairs(data.Folders) do
			table.insert(esp._CoreCons,folder.ChildAdded:Connect(function(child) data:OnSpawned(esp,child,true) end))
			for _,child in ipairs(folder:GetChildren()) do task.spawn(data.OnSpawned,data,esp,child) end
		end
		table.insert(esp._CoreCons,game:GetService("UserInputService").InputBegan:Connect(function(input,busy)
			if input.KeyCode == esp.ToggleKey and not busy then esp:Toggle() end
		end))
		esp:Toggle()
		return esp
	end
	warn("Loaded ESP Library by \"https://github.com/shadowsaz/\"")
	getgenv()._355743517261299712 = lib
end
